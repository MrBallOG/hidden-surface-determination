import{S as $,i as E,s as U,e as k,c as R,a as B,d as F,b as S,g as O,J as W,K,n as j,w as H,L as J,x as G,y as Q,z as _,r as tt,p as rt,C as et}from"../chunks/index-8cf79ea7.js";class o{constructor(t){this.d=t}static empty(){return new o([0,0,0,1])}static from(t,r,e,s){return new o([t,r,e,s||1])}add(t){return o.from(this.x+t.x,this.y+t.y,this.z+t.z,this.w)}subtract(t){return o.from(this.x-t.x,this.y-t.y,this.z-t.z,this.w)}multiply(t){return o.from(this.x*t,this.y*t,this.z*t,this.w)}divide(t){return o.from(this.x/t,this.y/t,this.z/t,this.w)}dotProduct(t){return this.x*t.x+this.y*t.y+this.z*t.z}length(){return Math.sqrt(this.dotProduct(this))}normalise(){const t=this.length();return t!=0?o.from(this.x/t,this.y/t,this.z/t,this.w):o.from(0,0,0,this.w)}crossProduct(t){const r=o.empty();return r.x=this.y*t.z-this.z*t.y,r.y=this.z*t.x-this.x*t.z,r.z=this.x*t.y-this.y*t.x,r}copy(){return new o([this.x,this.y,this.z,this.w])}toVec2d(){return n.from(this.x,this.y)}get x(){return this.d[0]}set x(t){this.d[0]=t}get y(){return this.d[1]}set y(t){this.d[1]=t}get z(){return this.d[2]}set z(t){this.d[2]=t}get w(){return this.d[3]}set w(t){this.d[3]=t}}class n{constructor(t){this.d=t}static from(t,r,e){return new n([t,r,e||1])}static empty(){return new n([0,0,1])}subtract(t){return n.from(this.x-t.x,this.y-t.y)}add(t){return n.from(this.x+t.x,this.y-t.y)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}copy(){return new n([this.x,this.y,this.w])}get x(){return this.d[0]}set x(t){this.d[0]=t}get y(){return this.d[1]}set y(t){this.d[1]=t}get w(){return this.d[2]}set w(t){this.d[2]=t}}class u{constructor(t){this.rows=t}static lookAt(t,r,e){const s=r.subtract(t).normalise(),i=s.multiply(e.dotProduct(s)),a=e.subtract(i).normalise(),h=a.crossProduct(s);return new u([h.x,h.y,h.z,0,a.x,a.y,a.z,0,s.x,s.y,s.z,0,t.x,t.y,t.z,1]).quickInverse()}static identity(){const t=u.empty();return t.rows[0]=1,t.rows[1*4+1]=1,t.rows[2*4+2]=1,t.rows[3*4+3]=1,t}static rotationX(t){const r=u.empty();return r.rows[0]=1,r.rows[1*4+1]=Math.cos(t),r.rows[1*4+2]=Math.sin(t),r.rows[2*4+1]=-Math.sin(t),r.rows[2*4+2]=Math.cos(t),r.rows[3*4+3]=1,r}static rotationY(t){const r=u.empty();return r.rows[0*4+0]=Math.cos(t),r.rows[0*4+2]=-Math.sin(t),r.rows[1*4+1]=1,r.rows[2*4+0]=Math.sin(t),r.rows[2*4+2]=Math.cos(t),r.rows[3*4+3]=1,r}static rotationZ(t){const r=u.empty();return r.rows[0]=Math.cos(t),r.rows[0*4+1]=Math.sin(t),r.rows[1*4+0]=-Math.sin(t),r.rows[1*4+1]=Math.cos(t),r.rows[2*4+2]=1,r.rows[3*4+3]=1,r}static empty(){return new u([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])}multiplyVec3d(t){const r=o.empty();for(let e=0;e<4;e++)r.d[e]=this.mulVec4ByCol(e,t);return r}mulVec4ByCol(t,r){let e=0;for(let s=0;s<3;s++)e+=this.rows[s*4+t]*r.d[s];return e+=this.rows[3*4+t],e}multiplyWithVec3d(t){const r=o.empty();for(let e=0;e<4;e++)r.d[e]=this.mulRowbyVec4(e,t);return r}mulRowbyVec4(t,r){let e=0;for(let s=0;s<4;s++)e+=this.rows[s+4*t]*r.d[s];return e}quickInverse(){const t=u.empty();return t.rows[0*4+0]=this.rows[0*4+0],t.rows[0*4+1]=this.rows[1*4+0],t.rows[0*4+2]=this.rows[2*4+0],t.rows[0*4+3]=0,t.rows[1*4+0]=this.rows[0*4+1],t.rows[1*4+1]=this.rows[1*4+1],t.rows[1*4+2]=this.rows[2*4+1],t.rows[1*4+3]=0,t.rows[2*4+0]=this.rows[0*4+2],t.rows[2*4+1]=this.rows[1*4+2],t.rows[2*4+2]=this.rows[2*4+2],t.rows[2*4+3]=0,t.rows[3*4+0]=-(this.rows[3*4+0]*t.rows[0*4+0]+this.rows[3*4+1]*t.rows[1*4+0]+this.rows[3*4+2]*t.rows[2*4+0]),t.rows[3*4+1]=-(this.rows[3*4+0]*t.rows[0*4+1]+this.rows[3*4+1]*t.rows[1*4+1]+this.rows[3*4+2]*t.rows[2*4+1]),t.rows[3*4+2]=-(this.rows[3*4+0]*t.rows[0*4+2]+this.rows[3*4+1]*t.rows[1*4+2]+this.rows[3*4+2]*t.rows[2*4+2]),t.rows[3*4+3]=1,t}static matrixInverse(t){const r=u.empty();return r.rows[0*4+0]=t.rows[0*4+0],r.rows[0*4+1]=t.rows[1*4+0],r.rows[0*4+2]=t.rows[2*4+0],r.rows[0*4+3]=0,r.rows[1*4+0]=t.rows[0*4+1],r.rows[1*4+1]=t.rows[1*4+1],r.rows[1*4+2]=t.rows[2*4+1],r.rows[1*4+3]=0,r.rows[2*4+0]=t.rows[0*4+2],r.rows[2*4+1]=t.rows[1*4+2],r.rows[2*4+2]=t.rows[2*4+2],r.rows[2*4+3]=0,r.rows[3*4+0]=-(t.rows[3*4+0]*r.rows[0*4+0]+t.rows[3*4+1]*r.rows[1*4+0]+t.rows[3*4+2]*r.rows[2*4+0]),r.rows[3*4+1]=-(t.rows[3*4+0]*r.rows[0*4+1]+t.rows[3*4+1]*r.rows[1*4+1]+t.rows[3*4+2]*r.rows[2*4+1]),r.rows[3*4+2]=-(t.rows[3*4+0]*r.rows[0*4+2]+t.rows[3*4+1]*r.rows[1*4+2]+t.rows[3*4+2]*r.rows[2*4+2]),r.rows[3*4+3]=1,r}multiply(t){let r=u.empty();for(let e=0;e<4;e++)for(let s=0;s<4;s++)for(let i=0;i<4;i++)r.rows[e*4+s]+=this.rows[e*4+i]*t.rows[i*4+s];return r}getV(t,r){return this.rows[t*4+r]}setV(t,r,e){this.rows[t*4+r]=e}}class m{constructor(t,r){this.eps=.001,this.vertexes=t,this.vertexes=[t[0].copy(),t[1].copy(),t[2].copy()],r?this.texCoords=r:this.texCoords=[n.empty(),n.empty(),n.empty()],this.normal=this.calcNormal().normalise()}static from(t,r,e){return new m([t,r,e])}static textured(t,r,e,s,i,a){return new m([t,r,e],[s,i,a])}static empty(){return new m([o.empty(),o.empty(),o.empty()])}multiplyByMatrix(t){let r=this.copy();for(let e=0;e<3;e++)r.vertexes[e]=t.multiplyVec3d(this.vertexes[e]);return r}avgDistanceToCamera(t){return(this.p1.subtract(t).length()+this.p2.subtract(t).length()+this.p3.subtract(t).length())/3}calcNormal(){let t=this.p2.subtract(this.p1),r=this.p3.subtract(this.p1);return o.from(t.y*r.z-t.z*r.y,t.z*r.x-t.x*r.z,t.x*r.y-t.y*r.x)}equationPlane(){if(this.equation_plane)return this.equation_plane;let t=this.p2.x-this.p1.x,r=this.p2.y-this.p1.y,e=this.p2.z-this.p1.z,s=this.p3.x-this.p1.x,i=this.p3.y-this.p1.y,a=this.p3.z-this.p1.z,h=r*a-i*e,l=s*e-t*a,d=t*i-r*s,y=-h*this.p1.x-l*this.p1.y-d*this.p1.z;return this.equation_plane=o.from(h,l,d,y),this.equation_plane}calcZOn(t,r){let e=this.equationPlane();return-(e.x*t+e.y*r+e.w)/e.z}getTextureCoords(t,r){let e=o.from(t,r,this.calcZOn(t,r)),s=this.p1,i=this.p2,a=this.p3,h=this.area,l=Z(s,i,e)/h,d=Z(i,a,e)/h,y=Z(a,s,e)/h,f=n.from(this.p1tex.x/this.p1.w*d+this.p2tex.x/this.p2.w*y+this.p3tex.x/this.p3.w*l,this.p1tex.y/this.p1.w*d+this.p2tex.y/this.p2.w*y+this.p3tex.y/this.p3.w*l,1/this.p1.w*d+1/this.p2.w*y+1/this.p3.w*l);return n.from(f.x/f.w,f.y/f.w)}getTextureCoords2d(t,r){let e=n.from(t,r),s=this.p1.toVec2d(),i=this.p2.toVec2d(),a=this.p3.toVec2d(),h=X(s,i,a),l=X(s,i,e)/h,d=X(i,a,e)/h,y=X(a,s,e)/h;return n.from(this.p1tex.x*d+this.p2tex.x*y+this.p3tex.x*l,this.p1tex.y*d+this.p2tex.y*y+this.p3tex.y*l)}pointInside(t,r){const e=(y,f,M,c,x,v)=>(y-x)*(c-v)-(M-x)*(f-v);let s=this.vertexes,i,a,h,l,d;return i=e(t,r,s[0].x,s[0].y,s[1].x,s[1].y),a=e(t,r,s[1].x,s[1].y,s[2].x,s[2].y),h=e(t,r,s[2].x,s[2].y,s[0].x,s[0].y),l=i<0||a<0||h<0,d=i>0||a>0||h>0,!(l&&d)}copy(){return new m([this.p1.copy(),this.p2.copy(),this.p3.copy()],[this.p1tex.copy(),this.p2tex.copy(),this.p3tex.copy()])}getXRange(t){let r=[];return r.push(this.getXAtY(t,this.p1,this.p1p2LineCoeffs)),r.push(this.getXAtY(t,this.p1,this.p1p3LineCoeffs)),r.push(this.getXAtY(t,this.p2,this.p2p3LineCoeffs)),r=r.filter(e=>e!==null&&(this.pointInside(e,t)||this.pointInside(e-this.eps,t)||this.pointInside(e+this.eps,t))),[Math.min(...r),Math.max(...r)]}getXAtY(t,r,e){return e[0]===0&&r.y===t||e[1]===0?r.x:e[0]===0&&r.y!==t?null:-((e[1]*t+e[2])/e[0])}calcLinesCoeffs(){this.p1p2LineCoeffs=this.calcLineCoeffs(this.p1,this.p2),this.p1p3LineCoeffs=this.calcLineCoeffs(this.p1,this.p3),this.p2p3LineCoeffs=this.calcLineCoeffs(this.p2,this.p3)}calcLineCoeffs(t,r){let e=t.y-r.y,s=r.x-t.x,i=t.x*r.y-r.x*t.y;return[e,s,i]}setArea(){this.area=Z(this.p1,this.p2,this.p3)}setMinY(){this.minYVal=Math.min(this.p1.y,this.p2.y,this.p3.y)}setMaxY(){this.maxYVal=Math.max(this.p1.y,this.p2.y,this.p3.y)}get maxY(){return this.maxYVal}get minY(){return this.minYVal}get p1(){return this.vertexes[0]}get p2(){return this.vertexes[1]}get p3(){return this.vertexes[2]}get p1tex(){return this.texCoords[0]}get p2tex(){return this.texCoords[1]}get p3tex(){return this.texCoords[2]}}function X(w,t,r){return Math.abs((w.x*t.y+t.x*r.y+r.x*w.y-w.y*t.x-t.y*r.x-r.y*w.x)/2)}function Z(w,t,r){let e=r.subtract(w),s=t.subtract(w);return e.crossProduct(s).length()/2}class I{constructor(t){this.triangles=t}add(t){this.triangles.push(t)}addMesh(t){for(let r=0;r<t.triangles.length;r++)this.triangles.push(t.triangles[r])}multiplyByMatrix(t){const r=[];for(let e=0;e<this.triangles.length;e++){const s=this.triangles[e],i=s.copy();for(let a=0;a<3;a++)i.vertexes[a]=t.multiplyVec3d(s.vertexes[a]);r.push(i)}return new I(r)}translateX(t){const r=[];for(const e of this.triangles){const s=e.copy();for(let i=0;i<3;i++){const a=e.vertexes[i];s.vertexes[i]=o.from(a.d[0]+t,a.d[1],a.d[2])}r.push(s)}return new I(r)}translateY(t){const r=[];for(const e of this.triangles){const s=e.copy();for(let i=0;i<3;i++){const a=e.vertexes[i];s.vertexes[i]=o.from(a.d[0],a.d[1]+t,a.d[2])}r.push(s)}return new I(r)}translateZ(t){const r=[];for(const e of this.triangles){const s=e.copy();for(let i=0;i<3;i++){const a=e.vertexes[i];s.vertexes[i]=o.from(a.x,a.y,a.z+t)}r.push(s)}return new I(r)}rotateX(t){const r=[],e=u.rotationX(t);for(let s of this.triangles){let i=s.copy();for(let a=0;a<3;a++)i.vertexes[a]=e.multiplyVec3d(s.vertexes[a]);r.push(i)}return new I(r)}}const A=()=>new I([m.textured(o.from(0,0,0),o.from(0,1,0),o.from(1,1,0),n.from(0,1),n.from(0,0),n.from(1,0)),m.textured(o.from(0,0,0),o.from(1,1,0),o.from(1,0,0),n.from(0,1),n.from(1,0),n.from(1,1)),m.textured(o.from(1,0,0),o.from(1,1,0),o.from(1,1,1),n.from(0,1),n.from(0,0),n.from(1,0)),m.textured(o.from(1,0,0),o.from(1,1,1),o.from(1,0,1),n.from(0,1),n.from(1,0),n.from(1,1)),m.textured(o.from(1,0,1),o.from(1,1,1),o.from(0,1,1),n.from(0,1),n.from(0,0),n.from(1,0)),m.textured(o.from(1,0,1),o.from(0,1,1),o.from(0,0,1),n.from(0,1),n.from(1,0),n.from(1,1)),m.textured(o.from(0,0,1),o.from(0,1,1),o.from(0,1,0),n.from(0,1),n.from(0,0),n.from(1,0)),m.textured(o.from(0,0,1),o.from(0,1,0),o.from(0,0,0),n.from(0,1),n.from(1,0),n.from(1,1)),m.textured(o.from(0,1,0),o.from(0,1,1),o.from(1,1,1),n.from(0,1),n.from(0,0),n.from(1,0)),m.textured(o.from(0,1,0),o.from(1,1,1),o.from(1,1,0),n.from(0,1),n.from(1,0),n.from(1,1)),m.textured(o.from(1,0,1),o.from(0,0,1),o.from(0,0,0),n.from(0,1),n.from(0,0),n.from(1,0)),m.textured(o.from(1,0,1),o.from(0,0,0),o.from(1,0,0),n.from(0,1),n.from(1,0),n.from(1,1))]),st=()=>new I([m.textured(o.from(0,0,0),o.from(0,1+1,0),o.from(1,1+1,0),n.from(0,1),n.from(0,0),n.from(1,0)),m.textured(o.from(0,0,0),o.from(1,1+1,0),o.from(1,0,0),n.from(0,1),n.from(1,0),n.from(1,1)),m.textured(o.from(1,0,0),o.from(1,1+1,0),o.from(1,1+1,1),n.from(0,1),n.from(0,0),n.from(1,0)),m.textured(o.from(1,0,0),o.from(1,1+1,1),o.from(1,0,1),n.from(0,1),n.from(1,0),n.from(1,1)),m.textured(o.from(1,0,1),o.from(1,1+1,1),o.from(0,1+1,1),n.from(0,1),n.from(0,0),n.from(1,0)),m.textured(o.from(1,0,1),o.from(0,1+1,1),o.from(0,0,1),n.from(0,1),n.from(1,0),n.from(1,1)),m.textured(o.from(0,0,1),o.from(0,1+1,1),o.from(0,1+1,0),n.from(0,1),n.from(0,0),n.from(1,0)),m.textured(o.from(0,0,1),o.from(0,1+1,0),o.from(0,0,0),n.from(0,1),n.from(1,0),n.from(1,1)),m.textured(o.from(0,1+1,0),o.from(0,1+1,1),o.from(1,1+1,1),n.from(0,1),n.from(0,0),n.from(1,0)),m.textured(o.from(0,1+1,0),o.from(1,1+1,1),o.from(1,1+1,0),n.from(0,1),n.from(1,0),n.from(1,1)),m.textured(o.from(1,0,1),o.from(0,0,1),o.from(0,0,0),n.from(0,1),n.from(0,0),n.from(1,0)),m.textured(o.from(1,0,1),o.from(0,0,0),o.from(1,0,0),n.from(0,1),n.from(1,0),n.from(1,1))]);class ot extends u{constructor(t,r,e,s,i){const a=1/Math.tan(t/2);super([i/s*a,0,0,0,0,a,0,0,0,0,r/(r-e),1,0,0,(-r-e)/(r-e),0])}projectMesh(t){const r=[];for(let e=0;e<t.triangles.length;e++)r.push(this.projectTris(t.triangles[e]));return new I(r)}projectTris(t){const r=t.copy();for(let e=0;e<3;e++)r.vertexes[e]=this.projectVec(t.vertexes[e]);return r}projectVec(t){const r=this.multiplyVec3d(t);return r.d[3]!=0&&(r.x/=r.w,r.y/=r.w,r.z/=r.w),r}}class it{constructor(t,r,e){this.data=t,this.width=r,this.height=e}getPx(t,r){let e=Math.floor(t*this.width),s=Math.floor(r*this.height);if(e==0||e===this.width-1||s===0||s===this.height-1){let h=(e+this.width*s)*3;return new C([this.data[h],this.data[h+1],this.data[h+2]])}let i=(e+this.width*s)*3,a=C.rgb(0,0,0);for(let h=-1;h<2;h++)for(let l=-1;l<2;l++){let d=(h+l*this.width)*3;a.r+=this.data[i+d],a.g+=this.data[i+d+1],a.b+=this.data[i+d+2]}return a.r/=9,a.g/=9,a.b/=9,a}}class C{constructor(t){this.data=t}static rgb(t,r,e){return new C([t,r,e])}get r(){return this.data[0]}set r(t){this.data[0]=t}get g(){return this.data[1]}set g(t){this.data[1]=t}get b(){return this.data[2]}set b(t){this.data[2]=t}}const b=new C([255,204,0]),V=new C([0,87,217]),at=()=>{let w=512,t=512,r=new Uint8ClampedArray(w*t*3),e=b.r,s=b.g,i=b.b;const a=()=>{e==V.r?(e=b.r,s=b.g,i=b.b):(e=V.r,s=V.g,i=V.b)};for(let h=0;h<t;h++){h%128===0&&a();for(let l=0;l<w;l++){l%128===0&&a();let d=(h*w+l)*3;r[d]=e,r[d+1]=s,r[d+2]=i}}return new it(r,w,t)},nt=at();class D{constructor(t,r){this.cameraPos=new ct,this.lightPosNormalised=o.from(-4,-3,-7).normalise(),this.eps=.001,this.cameraInfo=new ht(t,r)}clear(t){t.fillStyle="rgb(31, 28, 28)",t.fillRect(0,0,this.cameraInfo.width,this.cameraInfo.height)}drawMesh(t,r){this.ctx=r;let e=this.cameraPos.cameraPos,s=new I([]);for(let a=0;a<t.triangles.length;a++){let h=t.triangles[a];h.p1.subtract(e).dotProduct(h.normal)<0&&s.add(h)}for(let a=0;a<s.triangles.length;a++)s.triangles[a]=this.project(s.triangles[a]),s.triangles[a].setArea(),s.triangles[a].setMaxY(),s.triangles[a].setMinY(),s.triangles[a].calcLinesCoeffs();let i=this.ctx.getImageData(0,0,this.cameraInfo.width,this.cameraInfo.height);for(let a=0;a<this.cameraInfo.height;a++){let h=this.yTo3dSpace(a),l=s.triangles.filter(c=>c.maxY>=h&&c.minY<=h);if(l.length===0)continue;let d=l.map((c,x)=>[x,c.getXRange(h)]),y=new Set;d.forEach(c=>{y.add(c[1][0]),y.add(c[1][1])});let f=[...y].sort((c,x)=>c-x),M=f.map(c=>[this.x3dTo2dSpace(c),-1]);for(let c=1;c<f.length;c++){let x=f[c-1],v=f[c],P=[];for(let p=0;p<l.length;p++){let g=l[p];!(g.pointInside(x,h)&&g.pointInside(v,h))&&!(g.pointInside(x+this.eps,h)&&g.pointInside(v-this.eps,h))||P.push([p,g.calcZOn(x,h),g.calcZOn(v,h)])}P.length!=0&&(M[c][1]=P.sort((p,g)=>p[1]===g[1]?p[2]-g[2]:p[1]-g[1])[0][0])}for(let c=1;c<M.length;c++){let x=M[c-1][0],v=M[c][0],P=M[c][1];if(P===-1||x<0&&v<0||x>this.cameraInfo.width-1&&v>this.cameraInfo.width-1)continue;x<0&&(x=0),v>this.cameraInfo.width-1&&(v=this.cameraInfo.width-1);let p=l[P],g=p.normal.dotProduct(this.lightPosNormalised);g=Math.max(Math.min(g,1),.15);for(let z=x;z<v;z++){let L=p.getTextureCoords(this.xTo3dSpace(z),h),T=nt.getPx(L.x,L.y),Y=(a*i.width+z)*4;i.data[Y]=T.r*g,i.data[Y+1]=T.g*g,i.data[Y+2]=T.b*g,i.data[Y+3]=255}}}this.ctx.putImageData(i,0,0)}project(t){const r=this.cameraInfo.projMatrix,e=this.cameraPos.rotMatrix,s=this.cameraPos.cameraPos,i=t.copy();for(let a=0;a<3;a++){let h=t.vertexes[a].subtract(s);h=e.multiplyWithVec3d(h),i.vertexes[a]=r.projectVec(h)}return i}scaleXToCanvas(t){return(t+1)*(this.cameraInfo.width/2)}scaleYToCanvas(t){return(t+1)*(this.cameraInfo.height/2)}xTo3dSpace(t){return 2*t/this.cameraInfo.width-1}yTo3dSpace(t){return 2*t/this.cameraInfo.height-1}x3dTo2dSpace(t){return Math.ceil((t+1)*this.cameraInfo.width/2)}}class ht{constructor(t,r){this.fov=Math.PI/8,this.fovChange=Math.PI/32,this.zFar=1e5,this.zNear=.1,this.width=t,this.height=r,this.projMatrix=this.createProjectionMatrix()}createProjectionMatrix(){return new ot(this.fov,this.zFar,this.zNear,this.width,this.height)}posZoom(){this.fov-=this.fovChange,this.projMatrix=this.createProjectionMatrix()}negZoom(){this.fov+=this.fovChange,this.projMatrix=this.createProjectionMatrix()}}class ct{constructor(){this.vCamera=o.from(0,0,-6),this.moveFactor=.1,this.rotateFactor=Math.PI/128,this.rotationMatrix=u.identity(),this.rotationMatrixInverse=u.identity(),this.translationVecs=[o.from(this.moveFactor,0,0),o.from(-this.moveFactor,0,0),o.from(0,this.moveFactor,0),o.from(0,-this.moveFactor,0),o.from(0,0,this.moveFactor),o.from(0,0,-this.moveFactor)],this.rotXPos=u.rotationX(this.rotateFactor),this.rotXNeg=u.rotationX(-this.rotateFactor),this.rotYPos=u.rotationY(-this.rotateFactor),this.rotYNeg=u.rotationY(this.rotateFactor),this.rotZPos=u.rotationZ(this.rotateFactor),this.rotZNeg=u.rotationZ(-this.rotateFactor)}get rotMatrix(){return this.rotationMatrix}moveForward(){this.translate(4)}moveBackward(){this.translate(5)}moveLeft(){this.translate(1)}moveRight(){this.translate(0)}moveUp(){this.translate(3)}moveDown(){this.translate(2)}translate(t){const r=this.translationVecs[t],e=this.rotationMatrixInverse.multiplyWithVec3d(r);this.vCamera=this.vCamera.add(e)}rotatePosX(){this.rotationMatrix=this.rotXPos.multiply(this.rotationMatrix),this.rotationMatrixInverse=u.matrixInverse(this.rotationMatrix)}rotateNegX(){this.rotationMatrix=this.rotXNeg.multiply(this.rotationMatrix),this.rotationMatrixInverse=u.matrixInverse(this.rotationMatrix)}rotatePosY(){this.rotationMatrix=this.rotYPos.multiply(this.rotationMatrix),this.rotationMatrixInverse=u.matrixInverse(this.rotationMatrix)}rotateNegY(){this.rotationMatrix=this.rotYNeg.multiply(this.rotationMatrix),this.rotationMatrixInverse=u.matrixInverse(this.rotationMatrix)}rotatePosZ(){this.rotationMatrix=this.rotZPos.multiply(this.rotationMatrix),this.rotationMatrixInverse=u.matrixInverse(this.rotationMatrix)}rotateNegZ(){this.rotationMatrix=this.rotZNeg.multiply(this.rotationMatrix),this.rotationMatrixInverse=u.matrixInverse(this.rotationMatrix)}get cameraPos(){return this.vCamera}}function lt(w){let t,r,e,s;return{c(){t=k("div"),r=k("canvas"),this.h()},l(i){t=R(i,"DIV",{class:!0});var a=B(t);r=R(a,"CANVAS",{id:!0,class:!0}),B(r).forEach(F),a.forEach(F),this.h()},h(){S(r,"id","camera_canvas"),S(r,"class","svelte-n593cm"),S(t,"class","svelte-n593cm")},m(i,a){O(i,t,a),W(t,r),w[2](r),e||(s=K(window,"keydown",w[1]),e=!0)},p:j,i:j,o:j,d(i){i&&F(t),w[2](null),e=!1,s()}}}const N=1200,q=700;function mt(w,t,r){let e,s,i=new D(N,q),a=new I([]),h=A().translateZ(2).translateX(-2),l=A().translateZ(2).translateX(.5),d=A().translateZ(4).translateX(-2.5),y=st().translateZ(4).translateX(.5).translateY(-1);a.addMesh(h),a.addMesh(l),a.addMesh(d),a.addMesh(y),H(()=>{r(0,e.width=N,e),r(0,e.height=q,e),s=e.getContext("2d"),i.clear(s),i.drawMesh(a,s)});const f=()=>{i.clear(s),i.drawMesh(a,s)},M=[["Forward",()=>i.cameraPos.moveForward()],["Backward",()=>i.cameraPos.moveBackward()],["Up",()=>i.cameraPos.moveUp()],["Down",()=>i.cameraPos.moveDown()],["Left",()=>i.cameraPos.moveLeft()],["Right",()=>i.cameraPos.moveRight()]],c=[["Rotate X",()=>i.cameraPos.rotatePosX()],["Rotate -X",()=>i.cameraPos.rotateNegX()],["Rotate Y",()=>i.cameraPos.rotatePosY()],["Rotate -Y",()=>i.cameraPos.rotateNegY()],["Rotate Z",()=>i.cameraPos.rotatePosZ()],["Rotate -Z",()=>i.cameraPos.rotateNegZ()]],x=P=>{let p=P.key;p=="a"?(M[4][1](),f()):p==="d"?(M[5][1](),f()):p==="w"?(M[2][1](),f()):p==="s"?(M[3][1](),f()):p==="q"?(M[1][1](),f()):p==="e"?(M[0][1](),f()):p==="j"?(c[2][1](),f()):p==="l"?(c[3][1](),f()):p==="i"?(c[0][1](),f()):p==="k"?(c[1][1](),f()):p==="u"?(c[4][1](),f()):p==="o"?(c[5][1](),f()):p==="z"?(i.cameraInfo.posZoom(),f()):p==="x"?(i.cameraInfo.negZoom(),f()):p==="r"&&(i=new D(N,q),f())};function v(P){J[P?"unshift":"push"](()=>{e=P,r(0,e)})}return[e,x,v]}class ft extends ${constructor(t){super(),E(this,t,mt,lt,U,{})}}function pt(w){let t,r;return t=new ft({}),{c(){G(t.$$.fragment)},l(e){Q(t.$$.fragment,e)},m(e,s){_(t,e,s),r=!0},p:j,i(e){r||(tt(t.$$.fragment,e),r=!0)},o(e){rt(t.$$.fragment,e),r=!1},d(e){et(t,e)}}}class wt extends ${constructor(t){super(),E(this,t,null,pt,U,{})}}export{wt as default};
